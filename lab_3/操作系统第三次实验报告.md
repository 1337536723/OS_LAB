## 操作系统实验三 同步问题

> ​                                                                                                          16281049   王晗炜  计科1601

#### 实验目的

- **系统调用的进一步理解**
- **进程上下文切换**
- **同步的方法**

#### 实验题目

1. **通过fork的方式，产生4个进程P1,P2,P3,P4，每个进程打印输出自己的名字，例如P1输出“I am the process P1”。要求P1最先执行，P2、P3互斥执行，P4最后执行。通过多次测试验证实现是否正确。**

   - 根据题目执行顺序要求画出前驱图

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqoscb11j305x05udfs.jpg)

     

   - 四个进程实现前驱关系所需要的信号量

     经分析可知若需达到以上执行顺序的要求，共需要三个信号量来进行进程之间的约束：

     - **mySem_1**：保证P2和P3在P1之后互斥执行，初始值为0
     - **mySem_2**：保证P4在P2之后运行，初始值为0
     - **mySem_3**：保证P4在P3之后运行，初始值为0

     | 进程 |               执行前                |               执行后                |
     | :--: | :---------------------------------: | :---------------------------------: |
     |  P1  |                 无                  |          sem_post(mySem_1)          |
     |  P2  |          sem_wait(mySem_1)          | sem_post(mySem_1) sem_post(mySem_2) |
     |  P3  |          sem_wait(mySem_1)          | sem_post(mySem_1) sem_post(mySem_3) |
     |  P4  | sem_wait(mySem_2) sem_wait(mySem_3) | sem_post(mySem_2) sem_post(mySem_3) |

     在进程执行的过程中，因为三个信号量的初始值均为0，只有P1执行前没有wait要求，因此P1一定会是第一个执行的，在其执行完成后，会对mySem_1信号量进行post操作，使其值变为1，如此处于wait状态下的P2和P3进程便可有一个可以进行工作、另一个继续等待，当其中一个执行完成后会再次post信号量mySem_1，另一个进程也可进入工作，如此便可完美实现互斥执行。而对于P4，信号量mySem_2和mySem_3对其的约束使得其只能在P2和P3均完成工作后进入工作，所以P4一定是最后一个进入工作的进程。

     如此一来，四个进程的前驱关系便通过这三个信号量实现了。

   - 实现源码`3-1.c`：

     ```c
     #include <stdio.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <unistd.h>
     #include <fcntl.h>
     #include <semaphore.h>
     
     int main(int argc,char *argv[]){
     	sem_t *mySem_1 = NULL; //控制p1、p2和p3进程打信号量
     	sem_t *mySem_2 = NULL; //控制p4进程打信号量
     	sem_t *mySem_3 = NULL; //控制p4进程打信号量
     	mySem_1 = sem_open("mySemName_1",O_CREAT,0666,0);
     	mySem_2 = sem_open("mySemName_2",O_CREAT,0666,0);
     	mySem_3 = sem_open("mySemName_3",O_CREAT,0666,0);
     	pid_t pid_1,pid_2,pid_3,pid_4;
     	pid_2 = fork();
     	if(pid_1 == 0){
     		pid_2 = fork();
     		if(pid_2 == 0){
     			pid_3 = fork();
     			if(pid_3 == 0){
     				pid_4 = fork();
     				if(pid_4 == 0){
     					sem_wait(mySem_2);
     					sem_wait(mySem_3);
     					printf("I an the process P4\n");
     					sem_post(mySem_2);
     					sem_post(mySem_3);				
     				}
     				else if(pid_4>0){
     					sem_wait(mySem_1);
     					printf("I an the process P3\n");
     					sem_post(mySem_1);	
     					sem_post(mySem_3);	
     				}		
     			}
     			else if(pid_3>0){
     				sem_wait(mySem_1);
     				printf("I an the process P2\n");
     				sem_post(mySem_1);	
     				sem_post(mySem_2);			
     			}	
     		}
     		else if(pid_2>0){
     			printf("I an the process P1\n");
     	        sem_post(mySem_1);
     		}
     	}
     	sem_close(mySem_1);
     	sem_close(mySem_2);
     	sem_close(mySem_3);
     	unlink("mySemName_1");
     	unlink("mySemName_2");
     	unlink("mySemName_3");
     	return 0;
     }
     ```

   - 源码执行流程图

     题目中要求使用fork的方式创建4个进程，而进程工作执行的顺序已由上文给出，因此以下只给出程序创建进程的顺序。

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqph0cx7j30uf05faaq.jpg)

     

   - 测试情况

     在Linux终端下使用gcc编译该源程序

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqqflbp5j31by00v74o.jpg)

     连续多次运行程序并观察结果：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqr34yt4j30xq0getdp.jpg)

     可知只会出现P1->P2->P3->P4和P1->P3->P2->P4两种运行次序，与此前分析的一致。

2. **火车票余票数ticketCount 初始值为1000，有一个售票线程，一个退票线程，各循环执行多次。添加同步机制，使得结果始终正确。要求多次测试添加同步机制前后的实验效果。**(*说明：为了更容易产生并发错误，可以在适当的位置增加一些pthread_yield()，放弃CPU，并强制线程频繁切换，例如售票线程的关键代码：*

   *temp=ticketCount;*

   *pthread_yield();*

   *temp=temp-1;*

   *pthread_yield();*

   *ticketCount=temp;*

   *退票线程的关键代码：*

   *temp=ticketCount;*

   *pthread_yield();*

   *temp=temp+1;*

   *pthread_yield();*

   *ticketCount=temp;*

   ）

   - 问题分析

     这个问题实质上是一个多线程访问并修改临界资源的问题，如果两个线程在不加约束的情况下对临界资源进行修改则会使得有的线程会读取脏数据，造成错误。这里我们便需要使用一个信号量来制造两个线程之间的互斥访问，使得每次读取的数据都是正确的。

     在现实生活中火车票的购票与退票是一个并发量巨大的实际问题，这里我们的程序中只有两个线程，肯定是不能与其相提并论的，因此这里为了更加贴近其并发数量，使用了pthread_yield函数。此函数的作用为使当前线程暂时放弃CPU，使用另一个级别等于或高于当前线程的线程先运行。如果没有符合条件的线程，那么这个函数将会立刻返回然后继续执行当前线程的程序。因此在程序加入此函数会增加线程之间的切换，增加并发带来的脏数据问题。

   - 未添加同步代码及测试

     程序源代码`3-2_1.c`：

     ```c
     #include <stdio.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <unistd.h>
     #include <fcntl.h>
     #include <sys/stat.h>
     #include <semaphore.h>
     
     volatile int ticketCount = 1000;
     
     void *sell(void *arg){
     	int temp;
     	for(int i = 0;i < atoi(arg);i++){
     		temp = ticketCount;
     		pthread_yield();
     		temp = temp - 1;
     		pthread_yield();
     		ticketCount = temp;
     	}
     	return NULL;
     }
     
     void *refund(void *arg){
     	int temp;
     	for(int i = 0;i < atoi(arg);i++){
     		temp = ticketCount;
     		pthread_yield();
     		temp = temp + 1;
     		pthread_yield();
     		ticketCount = temp;
     	}
     	return NULL;
     }
     
     int main(int argc,char *argv[]){
     	pthread_t p1,p2;
     	if(argc!=3){
     		printf("3-2<sell_num refund_num>\n");
     		exit(1);
     	}
     	signal = sem_open("signal",O_CREAT,0666,1);
     	pthread_create(&p1,NULL,sell,argv[1]);
     	pthread_create(&p2,NULL,refund,argv[2]);
     	pthread_join(p1,NULL);
     	pthread_join(p2,NULL);
     	printf("余票数为：%d\n",ticketCount);
     	sem_close(signal);
     	return 0;
     }
     ```

     此程序除main函数外含两个函数，分别为sell售票函数，refund退票函数。ticketCount函数可被多个线程访问，代表余下的票数。

     在程序运行时，需要输入两个参数，分别代表售票数和退票数，否则便会直接在屏幕上打印出*3-2<sell_num refund_num>*提示错误。

     下面在Linux终端对程序进行编译并运行测试：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqslbca5j30ov01oweq.jpg)

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqss5u0ij30oy07jach.jpg)

     测试条件为卖票1000张，退票800张，正确的余票数应该为800张（1000-1000+800），但运行的5次结果无一为800且各不相同。这其实就是刚刚所说的读取脏数据带来的错误，具有很大的随机性，经分析我们可以得到次程序如此条件运行后的结果范围：

     - 最小值：0，假设售票线程和退票线程在开始一同读取了ticketCount（1000），此时退票线程先进行了800次，ticketCount被写为1800，但此后售票线程开始执行，其不会再次读取最新的ticketCount值，第一次执行写回的值为999（1000-1），直接将刚刚退票线程写入的1800覆盖了，之后再执行999次便会得到0余票，这是得到最小值的情况。
     - 最大值：1800，假设售票线程和退票线程在开始一同读取了ticketCount（1000），此时售票线程先进行了1000次，ticketCount被写为0，但此后退票线程开始执行，其不会再次读取最新的ticketCount值，第一次执行写回的值为1001（1000+1），直接将刚刚退票线程写入的0覆盖了，之后再执行799次便会得到800余票，这是得到最大值的情况。

     可知以上结果均在[0,1800]区间内，符合分析预期。

   - 添加同步之后的代码及测试

     在程序中使用信号量signal，将其初值设置为1，在售票进程或退票进程之前需进行sem_wait(signal)操作，访问完成之后再进行sem_post(signal)操作，如此便可实现两个线程之间互斥运行，以下为修改过后的源码`3-2_2.c`：

     ```c
     #include <stdio.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <unistd.h>
     #include <fcntl.h>
     #include <sys/stat.h>
     #include <semaphore.h>
     
     volatile int ticketCount = 1000;
     sem_t *signal = NULL;
     
     void *sell(void *arg){
     	int temp;
     	for(int i = 0;i < atoi(arg);i++){
     		sem_wait(signal);
     		temp = ticketCount;
     		pthread_yield();
     		temp = temp - 1;
     		pthread_yield();
     		ticketCount = temp;
     		sem_post(signal);
     	}
     	return NULL;
     }
     
     void *refund(void *arg){
     	int temp;
     	for(int i = 0;i < atoi(arg);i++){
     		sem_wait(signal);
     		temp = ticketCount;
     		pthread_yield();
     		temp = temp + 1;
     		pthread_yield();
     		ticketCount = temp;
     		sem_post(signal);
     	}
     	return NULL;
     }
     
     int main(int argc,char *argv[]){
     	pthread_t p1,p2;
     	if(argc!=3){
     		printf("3-2<sell_num refund_num>\n");
     		exit(1);
     	}
     	signal = sem_open("signal",O_CREAT,0666,1);
     	pthread_create(&p1,NULL,sell,argv[1]);
     	pthread_create(&p2,NULL,refund,argv[2]);
     	pthread_join(p1,NULL);
     	pthread_join(p2,NULL);
     	printf("余票数为：%d\n",ticketCount);
     	sem_close(signal);
     	return 0;
     }
     ```

     在Linux终端下编译并运行：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqt0ld5uj30oo01i3yr.jpg)

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqt4xhehj30jw07qdic.jpg)

     可见得到的结果均正确，可见该问题可以通过信号量互斥访问解决。

3. **一个生产者一个消费者线程同步。设置一个线程共享的缓冲区， char buf[10]。一个线程不断从键盘输入字符到buf,一个线程不断的把buf的内容输出到显示器。要求输出的和输入的字符和顺序完全一致。（在输出线程中，每次输出睡眠一秒钟，然后以不同的速度输入测试输出是否正确）。要求多次测试添加同步机制前后的实验效果。**

   - 问题分析

     此题是一个经典的生产者和消费者问题：输入线程产生字符，输出线程消耗字符，如果不考虑同步机制就让两个进程同时运行的话便会出现如下问题：

     - 输入进程产生字符过快，buf数组的资源被用尽，继续输入会导致数组越界或者之前输入的字符还未打印便被覆盖
     - 输出进程消耗字符过快，继续输出则会访问到为初始化的数组元素或者将之前打印过的字符再次打印

     根据以上存在的问题，我们可以通过使用信号量来实现两个进程之间的同步。略经分析我们需要初始化两个信号量：full和empty，其中full保证未打印的字符不超过10，empty保证存在需要打印的字符再进行打印。

     | 线程  |     执行前      |     执行后      |
     | :---: | :-------------: | :-------------: |
     | scan  | sem_wait(full)  | sem_post(empty) |
     | print | sem_wait(empty) | sem_post(full)  |

   - 未添加同步机制程序源码及其运行测试

     未添加同步机制的源代码`3-3_1.c`：

     ```c
     #include <stdio.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <unistd.h>
     
     char buf[10];
     
     void *scan(void *arg){
     	int i = 0;
     	while(1){
     		scanf("%c",&buf[(i++)%10]);
     	}
     }
     
     void *print(void *arg){
     	int i = 0;
     	while(1){
     		printf("输出buf[%d]：%c\n",i%10,buf[i%10]);
             i++;
     		sleep(1);
     	}
     	return NULL;
     }
     
     int main(int argc,char *argv[]){
     	pthread_t p1,p2;
     	pthread_create(&p1,NULL,scan,NULL);
     	pthread_create(&p2,NULL,print,NULL);
     	pthread_join(p1,NULL);
     	pthread_join(p2,NULL);
     	return 0;
     }
     ```

     在Linux终端下编译并运行：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqtd363gj30n600ljrf.jpg)

     输入过快：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqtktn82j30ih0d0758.jpg)

     此程序一开始执行便可看到尽管还没有进行输入，输出线程已经开始运行，输出的均为空字符，当一次性输入了一长串字符后，输出线程的输出开始有了内容，仔细观察易知和我们输入的顺序不完全一致，这便是因为输入过快导致还未被打印的字符被覆盖，buf字符串最多只能装载十个字符，当完成这一串输入之后buf内的值应为下表所示：

     | buf[0] | buf[1] | buf[2] | buf[3] | buf[4] | buf[5] | buf[6] | buf[7] | buf[8] | buf[9] |
     | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: | :----: |
     |   a    |   s    |   g    |   s    |   a    |   g    |   a    |   g    |   \n   |   g    |

     与结果相比对完全一致。

     输出过快：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqtrqbv4j30ho0eoab3.jpg)

     这里只输入123456789\n共十个字符串，接着分析输出线程的工作。当输入线程完成输入后，输出进程已经打印了好几个空字符，故没有从buf[0]开始打印，打印的次序便出了一些问题，当打印完buf[9]之后，其又将buf重新打印了一遍，在此过程中buf的值并未进行跟新，因此前文我们分析会出现的两个问题均在此程序中体现了。

   - 添加同步机制程序及其运行测试

     添加同步机制后的源程序`3-3_2.c`：

     ```c
     #include <stdio.h>
     #include <stdlib.h>
     #include <pthread.h>
     #include <unistd.h>
     #include <fcntl.h>
     #include <sys/stat.h>
     #include <semaphore.h>
     
     char buf[10];
     
     sem_t *full = NULL;
     sem_t *empty = NULL;
     
     void *scan(void *arg){
     	int i = 0;
     	while(1){
     		sem_wait(full);
     		scanf("%c",&buf[(i++)%10]);
     		sem_post(empty);
     	}
     }
     
     void *print(void *arg){
     	int i = 0;
     	while(1){
     		sem_wait(empty);
     		printf("输出buf[%d]：%c\n",i%10,buf[i%10]);
     		i++;
     		sem_post(full);
     		sleep(1);
     	}
     	return NULL;
     }
     
     int main(int argc,char *argv[]){
     	pthread_t p1,p2;
     	full = sem_open("full",O_CREAT,0666,10);
     	empty = sem_open("empty",O_CREAT,0666,0);
     	pthread_create(&p1,NULL,scan,NULL);
     	pthread_create(&p2,NULL,print,NULL);
     	pthread_join(p1,NULL);
     	pthread_join(p2,NULL);
     	sem_close(full);
     	sem_close(empty);
     	unlink("full");
     	unlink("empty");
     	return 0;
     }
     ```

     在Linux终端下编译并运行：

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqtx598jj30nx00pdfw.jpg)

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqu34zt4j30i001c0sq.jpg)

     在程序运行的一开始，输入线程未输入任何字符，这是输出线程被阻塞，不会打印任何字符，符合要求。

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqub1g2fj30ho08bmxi.jpg)

     当输入字符串长度大于10时，输出线程仍能按序输出这12个字符，符合要求。这里值得注意的是scanf函数在输入的过程中存在一个缓冲区，每次输入的字符会线存入缓冲区，当输入\n之后scanf函数便会从缓冲区中取出需要类型的字符，知道没有，因此这里的输入线程在实际运行过程中是受full信号量的阻塞控制的，但在实际工作过程中难以被察觉，直接的体现就是能是每个曾经输入的字符按序输出。

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1oqugfughj30hw0fzwf9.jpg)

     当一边输入少量字符一边输出时，我们可以看到以上结果仍正确无误，至此说明通过田间full和empty信号量能够完美实现输入和输出线程之间的同步。

4. **在Pintos操作系统中，增加一个系统调用，系统调用名为test_system_call()。无输入参数，输出为在显示器中打印输出：Hello. This is my test system call.**

5. **阅读Pintos操作系统，找到并阅读进程上下文切换的代码，说明实现的保存和恢复的上下文内容以及进程切换的工作流程。**

   由于涉及到进程的工作机制，我们可以优先从源码中的threads/thread.h部分开始探究。

   - 进程结构体简介

     我们首先进入pintos操作系统源码中的src/threads/thread.h，可以看到在开始做大部分声明之前有一长段注释：

     ```c
     /* A kernel thread or user process.
     
        Each thread structure is stored in its own 4 kB page.  The
        thread structure itself sits at the very bottom of the page
        (at offset 0).  The rest of the page is reserved for the
        thread's kernel stack, which grows downward from the top of
        the page (at offset 4 kB).  Here's an illustration:
     
             4 kB +---------------------------------+
                  |          kernel stack           |
                  |                |                |
                  |                |                |
                  |                V                |
                  |         grows downward          |
                  |                                 |
                  |                                 |
                  |                                 |
                  |                                 |
                  |                                 |
                  |                                 |
                  |                                 |
                  |                                 |
                  +---------------------------------+
                  |              magic              |
                  |                :                |
                  |                :                |
                  |               name              |
                  |              status             |
             0 kB +---------------------------------+
     
        The upshot of this is twofold:
     
           1. First, `struct thread' must not be allowed to grow too
              big.  If it does, then there will not be enough room for
              the kernel stack.  Our base `struct thread' is only a
              few bytes in size.  It probably should stay well under 1
              kB.
     
           2. Second, kernel stacks must not be allowed to grow too
              large.  If a stack overflows, it will corrupt the thread
              state.  Thus, kernel functions should not allocate large
              structures or arrays as non-static local variables.  Use
              dynamic allocation with malloc() or palloc_get_page()
              instead.
     
        The first symptom of either of these problems will probably be
        an assertion failure in thread_current(), which checks that
        the `magic' member of the running thread's `struct thread' is
        set to THREAD_MAGIC.  Stack overflow will normally change this
        value, triggering the assertion. */
     ```

     我们简单得对这段文字进行一下翻译：

     > 此结构体表示线程或用户进程。在项目中，您必须将自己的成员添加到struct thread中。您还可以更改或删除现有成员的定义。
     >
     > 每个结构线程占据其自己的内存页面的开头。页面的其余部分用于线程的堆栈，该堆栈从页面末尾向下增长。
     >
     > 这有两个注意事项。首先，不允许线程结构变得太大。否则内核堆栈就没有足够的空间。基本的线程结构的大小只有几个字节。它应该保持在1 kB以下。
     >
     > 其次，不得允许内核堆栈增长太大。如果堆栈溢出，则会破坏线程状态。因此，内核函数不应将大型结构或数组分配为非静态局部变量。使用malloc（）或palloc_get_page（）代替动态分配

     这段注释简单得向我们介绍了线程结构体的栈，也提醒了我们在后其修改此结构体时应该注意的一些事项，读完过后我们可以继续向下阅读结构体的具体声明代码：

     ```c
     struct thread
       {
         /* Owned by thread.c. */
         tid_t tid;                          /* Thread identifier. */
         enum thread_status status;          /* Thread state. */
         char name[16];                      /* Name (for debugging purposes). */
         uint8_t *stack;                     /* Saved stack pointer. */
         int priority;                       /* Priority. */
         int original_priority;              /* Priority, before donation */
         struct list_elem allelem;           /* List element for all threads list. */
         struct list_elem waitelem;          /* List element, stored in the wait_list queue */
         int64_t sleep_endtick;              /* The tick after which the thread should awake (if the thread is in sleep) */
     
         /* Shared between thread.c and synch.c. */
         struct list_elem elem;              /* List element, stored in the ready_list queue */
     
         // needed for priority donations
         struct lock *waiting_lock;          /* The lock object on which this thread is waiting (or NULL if not locked) */
         struct list locks;                  /* List of locks the thread holds (for multiple donations) */
     
     #ifdef USERPROG
         /* Owned by userprog/process.c. */
         uint32_t *pagedir;                  /* Page directory. */
     
         // Project 2: file descriptors and process table
         /* Owned by userprog/process.c and userprog/syscall.c */
     
         struct process_control_block *pcb;  /* Process Control Block */
         struct list child_list;             /* List of children processes of this thread,
                                               each elem is defined by pcb#elem */
     
         struct list file_descriptors;       /* List of file_descriptors the thread contains */
     
         struct file *executing_file;        /* The executable file of associated process. */
     
         uint8_t *current_esp;               /* The current value of the user program’s stack pointer.
                                                A page fault might occur in the kernel, so we might
                                                need to store esp on transition to kernel mode. (4.3.3) */
     #endif
     
     #ifdef VM
         // Project 3: Supplemental page table.
         struct supplemental_page_table *supt;   /* Supplemental Page Table. */
     
         // Project 3: Memory Mapped Files.
         struct list mmap_list;              /* List of struct mmap_desc. */
     #endif
     
         // Project 4: CWD.
         struct dir *cwd;
     
         /* Owned by thread.c. */
         unsigned magic;                     /* Detects stack overflow. */
       };
     ```

     结合注释和官方的说明文档，我们详细解释一下每个成员的含义以及作用：

     - tid_t **tid**：线程的线程标识符。每个线程必须具有在内核的整个生命周期内唯一的tid。默认情况下，tid_t是int的typedef，每个新线程接收数字上的下一个更高的tid，从初始进程的1开始。
     - enum thread_status **status**：线程的状态，一共有以下四种：
       - **THREAD_RUNNING**：线程在给定时间内正在运行。可以通过 thread_current（）函数返回正在运行的线程。
       - **THREAD_READY**：该线程已准备好运行，但它现在没有运行。可以选择线程以在下次调用调度程序时运行。就绪线程保存在名为ready_list的双向链表中
       - **THREAD_BLOCKED**：线程正在等待某些事务，例如锁定变为可用，要调用的中断。在通过调用thread_unblock（函数）转换到THREAD_READY状态之前，线程不会再次调度。
       - **THREAD_DYING**：切换到下一个线程后，调度程序将销毁该线程。
     - char **name[16]**：线程命名的字符串，至少前几个数组单元为字符。
     - uint8_t ***stack**：线程的栈指针。当线程运行时，CPU的堆栈指针寄存器跟踪堆栈的顶部，并且该成员未使用。但是当CPU切换到另一个线程时，该成员保存线程的堆栈指针。保存线程的寄存器不需要其他成员，因为必须保存的其他寄存器保存在堆栈中。
     - int **priority**：线程优先级，范围从PRI_MIN（0）到PRI_MAX（63）。较低的数字对应较低的优先级，因此优先级0是最低优先级，优先级63是最高优先级。
     - struct list_elem **allelem**：用于将线程链接到所有线程的列表中。每个线程在创建时都会插入到此列表中，并在退出时删除。应该使用thread_foreach（）函数来迭代所有线程。
     - struct list_elem **elem**：用于将线程放入双向链表：ready_list（准备好运行的线程列表）或sema_down（等待信号量的线程列表）。
     - uint32_t ***pagedir**：页表指针，用于将进程结构的虚拟地址映射到物理地址。
     - unsigned **magic**：始终设置为THREAD_MAGIC，它只是threads / thread.c中定义的任意数字，用于检测堆栈溢出。

     通过仔细分析这些结构体成员的含义，我们可以初步判断进程的保存与恢复状态也是用栈来实现的，栈指针***stack**可以的当作我们接下来分析的切入点。接着我们继续看一下进程函数的声明。

   - 进程函数简介

     首先我们打开源码中函数的声明，相比于结构体的定义，函数的声明并未撰写太多注释，我们只能根据函数名和官方说明文档来对部分可能在进程切换时用到的函数进行定位，在thread.c文件中根据其定义做进一步的探究。通过阅读函数的定义源码，我们可以看到进程的保存恢复以及切换和以下函数关系密切：

     ```c
     /* Schedules a new process.  At entry, interrupts must be off and
        the running process's state must have been changed from
        running to some other state.  This function finds another
        thread to run and switches to it.
     
        It's not safe to call printf() until thread_schedule_tail()
        has completed. */
     static void
     schedule (void)
     {
       struct thread *cur = running_thread ();
       struct thread *next = next_thread_to_run ();
       struct thread *prev = NULL;
     
       ASSERT (intr_get_level () == INTR_OFF);
       ASSERT (cur->status != THREAD_RUNNING);
       ASSERT (is_thread (next));
     
       if (cur != next)
         prev = switch_threads (cur, next);
       thread_schedule_tail (prev);
     }
     ```

     `schedule()`是负责切换线程的主要函数，其主要被`thread_block()`，`thread_exit()`，和`thread_yield()`这三次函数调用，下面我们仔细分析一下此函数的具体实现：首先其定义了三个thread结构体的指针，均为局部变量，cur指针指向`running_thread ()`函数的返回值，我们可以进入此函数观察其具体实现：

     ```c
     /* Returns the running thread. */
     struct thread *
     running_thread (void)
     {
       uint32_t *esp;
     
       /* Copy the CPU's stack pointer into `esp', and then round that
          down to the start of a page.  Because `struct thread' is
          always at the beginning of a page and the stack pointer is
          somewhere in the middle, this locates the curent thread. */
       asm ("mov %%esp, %0" : "=g" (esp));
       return pg_round_down (esp);
     }
     ```

     此函数嵌入了汇编代码，将CPU堆栈指针（总是在最顶端）复制到“esp”中，然后四舍五入到页面的开头。因为“struct thread”总是在页面的开头，而堆栈指针位于中间的某个位置，所以它定位当前线程。因此cur指针就是当前运行线程的指针。

     接着我们可以继续探究next指针的含义，进入`next_thread_to_run`函数：

     ```c
     /* Chooses and returns the next thread to be scheduled.  Should
        return a thread from the run queue, unless the run queue is
        empty.  (If the running thread can continue running, then it
        will be in the run queue.)  If the run queue is empty, return
        idle_thread. */
     static struct thread *
     next_thread_to_run (void)
     {
       if (list_empty (&ready_list))
         return idle_thread;
       else
         return list_entry (list_pop_front (&ready_list), struct thread, elem);
     }
     ```

     此函数选择并返回要调度的下一个线程。应该从运行队列返回一个线程，除非运行队列为空。如果运行队列为空，返回idle_thread。值得注意的是如果正在运行的线程可以继续运行，它便仍在运行队列中。这个函数的意义也很快就能弄清：返回下一个执行进程的指针。

     最后一个prev指针这里直接定义为了NULL，我们先不用着急考虑，接下来是三个断言判断，分别保证了此时中断关闭（程序不能被中断）、当前进程不在运行状态以及存在下一个进程。经过这三个断言判断后函数才到了核心部分：如果当前进程和下一个进程不相等，则调用`switch_threads (cur, next)`将当前进程和下一个进程进行切换。这里我们自然继续进入此函数中。

     `switch_threads (cur, next)`函数定义于switch.S中，使用汇编语言编写：

     ```scheme
     .globl switch_threads
     .func switch_threads
     switch_threads:
     	# Save caller's register state.
     	#
     	# Note that the SVR4 ABI allows us to destroy %eax, %ecx, %edx,
     	# but requires us to preserve %ebx, %ebp, %esi, %edi.  See
     	# [SysV-ABI-386] pages 3-11 and 3-12 for details.
     	#
     	# This stack frame must match the one set up by thread_create()
     	# in size.
     	pushl %ebx
     	pushl %ebp
     	pushl %esi
     	pushl %edi
     
     	# Get offsetof (struct thread, stack).
     .globl thread_stack_ofs
     	mov thread_stack_ofs, %edx
     
     	# Save current stack pointer to old thread's stack, if any.
     	movl SWITCH_CUR(%esp), %eax
     	movl %esp, (%eax,%edx,1)
     
     	# Restore stack pointer from new thread's stack.
     	movl SWITCH_NEXT(%esp), %ecx
     	movl (%ecx,%edx,1), %esp
     
     	# Restore caller's register state.
     	popl %edi
     	popl %esi
     	popl %ebp
     	popl %ebx
             ret
     .endfunc
     ```

     此函数的核心是将当前堆栈的指针保存至cur线程的堆栈，接着从next线程的堆栈中恢复当前堆栈的指针，也就是寄存器esp的操作。由此我们可以确定进程的保存与恢复就是利用CPU栈顶指针的变化进行的，进程的状态则是保存在自身的堆栈当中。switch_threads 函数的功能至此就已经结束。

     至此进程的切换还没有完全结束，在`schedule()`函数的最后一行还调用了`thread_schedule_tail (prev)`函数，在这里我们可以开始探究先前被定义为NULL的指针prev的作用，进入此函数阅读其定义：

     ```c
     /* Completes a thread switch by activating the new thread's page
        tables, and, if the previous thread is dying, destroying it.
     
        At this function's invocation, we just switched from thread
        PREV, the new thread is already running, and interrupts are
        still disabled.  This function is normally invoked by
        thread_schedule() as its final action before returning, but
        the first time a thread is scheduled it is called by
        switch_entry() (see switch.S).
     
        It's not safe to call printf() until the thread switch is
        complete.  In practice that means that printf()s should be
        added at the end of the function.
     
        After this function and its caller returns, the thread switch
        is complete. */
     void
     thread_schedule_tail (struct thread *prev)
     {
       struct thread *cur = running_thread ();
     
       ASSERT (intr_get_level () == INTR_OFF);
     
       /* Mark us as running. */
       cur->status = THREAD_RUNNING;
     
       /* Start new time slice. */
       thread_ticks = 0;
     
     #ifdef USERPROG
       /* Activate the new address space. */
       process_activate ();
     #endif
     
       /* If the thread we switched from is dying, destroy its struct
          thread.  This must happen late so that thread_exit() doesn't
          pull out the rug under itself.  (We don't free
          initial_thread because its memory was not obtained via
          palloc().) */
       if (prev != NULL && prev->status == THREAD_DYING && prev != initial_thread)
         {
           ASSERT (prev != cur);
           palloc_free_page (prev);
         }
     }
     ```

     根据函数的注释我们可以得知其功能是：通过激活新线程的页表完成线程切换，如果前一个线程正在死亡，则销毁它。接下来一步步观察其具体的执行步骤。

     首先其也会获取当前运行进程的指针并保证此时程序不能被中断。接着其会将当其运行进程的状态改变为THREAD_RUNNING以及初始化其时间切片，这可以看做切换进程后对新进程的一个激活。最后的部分表示如果我们切换的线程正在死亡，销毁它的struct线程。而我们传入的prev一定为NULL，所以在切换过程中这一部分并不会执行。

     至此进程保存与恢复以及切换的全部流程我们已经能够较为清晰得梳理出来。

   - 进程的保存与恢复及切换流程图

     ![](https://ws1.sinaimg.cn/large/007HSsnBly1g1pufyhfr4j30ia0g7aat.jpg)

     

